<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>OpenCV2 基础操作 &#8211; OnceMore</title>
<meta name="description" content="">
<meta name="keywords" content="OpenCV, Computer Visions">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV2 基础操作">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/blog/opencv2basic/">
<meta property="og:site_name" content="OnceMore">

<meta name="google-site-verification" content="i2ojlx9jpDBBAKREtMe5JMN1DCdIAlO97Qrf4vOuFF4">



<link rel="canonical" href="http://localhost:4000/blog/opencv2basic/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="OnceMore Feed">
<link rel="author" href="https://google.com/https://plus.google.com/110411659539252839234?rel=author">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/blog">博客</a></li>
		<li><a href="http://localhost:4000">主页</a></li>
		<li><a href="http://localhost:4000/blog/about/">关于博客</a></li>
		<li>
			<a href="#">文章目录</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/blog/posts/">所有文章</a></li>
				<li><a href="http://localhost:4000/blog/tags/">所有标签</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  <div class="entry-image">
    <img src="http://localhost:4000/images/homefeature.jpg" alt="OpenCV2 基础操作">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/blog/opencv2basic/" rel="bookmark" title="OpenCV2 基础操作">OpenCV2 基础操作</a></h1>
        
        <h2>August 04, 2014</h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
          Reading time ~4 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>快速了解OpenCV2基础操作，对于系统地开始阅读和学习文档有很大帮助。</p>

<h1 id="mat">Mat数据结构</h1>
<p>将获取的图像转码到数字设备时，采用一张数表(矩阵)来存储图像的每一像素强度<sup id="fnref:stdmat"><a href="#fn:stdmat" class="footnote">1</a></sup>。如下图所示，每个位置的数字表示当前位置的像素强度。</p>

<p><img src="/images/opencv2basic/mat.jpg" alt="Mat Demo" /></p>

<p>具体如何存储和获取这些像素值取决于具体需求，但是最终计算机内的所有的图像都是用各种矩阵来描述的。
OpenCV2采用<code>cv::Mat</code>类来存储图像，OpenCV2提供的C++ API中定义的类和函数都定义在命名空间<code>cv</code>中，可用如下方式声明:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span></code></pre></div>

<p>创建一个变量来存储图像：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">image</span><span class="p">;</span></code></pre></div>

<h2 id="section">存储方法</h2>
<p>存储像素值来表示图像涉及到<strong>色彩空间</strong>和<strong>数据类型</strong>。<strong>色彩空间</strong>是使用一组值来表示图像色彩的数学模型，最简单的是<strong>灰度值图像</strong>，处理的
颜色都是黑白的。对于彩色图像，可将每一个像素分解为若干个色彩成分通道，最流行的方式是<strong>RGB</strong>，因为人眼就是这样构建色彩世界的，三基色
为红，绿，蓝。有时会采用其它色彩空间，其对比如下：</p>

<ul>
  <li>RGB：最常见的色彩系统，用红绿蓝三色光的比例叠加来表示颜色，与人眼视觉系统原理类似，通常的显示系统也有采用这种色彩系统；</li>
  <li>HSV/HLS：将色彩分解为色调，饱和度，强度/亮度等元素，这种描述更自然直观，艺术家常用的色彩空间；</li>
  <li>CMYK : 使用青，品红，黄，黑四种油墨叠加在白色纸张上来体现彩色图像，常见于打印设备</li>
</ul>

<p>现实世界的像素强度值是连续的，而计算机只能直接对离散数据进行处理，因此需要将像素强度进行<strong>量化</strong>为离散数值，用相应<strong>数据类型</strong>存储，常采用与<code>char</code>数据
类型相同的数据空间：1字节或8比特，对应十进制为无符号(0~255)/带符号(-127~+127)。可以采用更大的数据类型来存储，会带来图像存储空间
的增长。</p>

<h2 id="opencv">OpenCV图像存储数据结构历史</h2>
<p>OpenCV诞生于2001年，最初版本运算库是基于C接口设计的，采用的C数据结构<code>IplImage</code>来存储图像，此方法引入了所有的C缺陷，其中最
主要的问题是手动管理内存，要求用户负责内存的分配和释放，这种情况在较小型的程序设计中影响并不大，当设计任务增长时用户可能会花
更多的时间来处理内存管理问题。如采用C接口来读入一个图像：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">IplImage</span><span class="o">*</span> <span class="n">iplImage</span> <span class="o">=</span> <span class="n">cvLoadImage</span><span class="p">(</span><span class="s">&quot;c:</span><span class="se">\\</span><span class="s">img.jpg&quot;</span><span class="p">);</span></code></pre></div>

<p>当不再使用变量时需要手动释放内存空间:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cvReleaseImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iplImage</span><span class="p">);</span></code></pre></div>

<p>OpenCV2引入了C++接口<code>cv::Mat</code>，当然也包括C++围绕着<strong>类(class)</strong>的设计模式的一种新概念:<strong>自动内存管理</strong>。</p>

<h2 id="section-1">引用计数系统</h2>
<p><code>Mat</code>从类的角度可分为两部分：<strong>矩阵头</strong>(矩阵大小，存储方法，初始地址)和一个指向数据单元的<strong>指针</strong>。矩阵头的大小是固定的，但是矩阵
的大小会随着存储图像的大小而改变。来看看<code>Mat</code>的部分类定义：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Mat</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ... a lot of methods ...</span>
    <span class="p">...</span>

    <span class="cm">/*! includes several bit-fields:</span>
<span class="cm">         - the magic signature</span>
<span class="cm">         - continuity flag</span>
<span class="cm">         - depth</span>
<span class="cm">         - number of channels</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//! the array dimensionality, &gt;= 2</span>
    <span class="kt">int</span> <span class="n">dims</span><span class="p">;</span>
    <span class="c1">//! the number of rows and columns or (-1, -1) when the array has more than 2 dimensions</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">;</span>
    <span class="c1">//! pointer to the data</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

    <span class="c1">//! pointer to the reference counter;</span>
    <span class="c1">// when array points to user-allocated data, the pointer is NULL</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">refcount</span><span class="p">;</span>

    <span class="c1">// other members</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre></div>

<p>当设定一个处理任务时，系统输入图像需要通过<code>Mat</code>传递，图像处理的计算量是庞大的，在传递
图像时我们不能随意地创建不必要的图像拷贝，因为这会影响程序的效率。为了解决这个问题，OpenCV采用<strong>引用计数系统(Reference Counting System)</strong>
，主要思想是每个矩阵对象采用各自的矩阵头，但是矩阵的数据存储单元能被多个对象共享。这样在拷贝操作时只需要拷贝矩阵头和指针
即可，不会拷贝存储单元数据。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">;</span>   <span class="c1">//只创建矩阵头</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">CV_LOAD_IMAGE_COLOR</span><span class="p">);</span>   <span class="c1">//分配存储单元</span>
<span class="n">Mat</span> <span class="nf">B</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>   <span class="c1">//拷贝操作(通过构造函数)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>  <span class="c1">//赋值操作</span></code></pre></div>

<p>以上示例代码中<code>A</code>,<code>B</code>,<code>C</code>最终都只指向同一个矩阵数据，但是它们的矩阵头不一样，所以修改其中任何一个对象都会影响其它对象。
实际应用中常采用这种方式，不同的对象共享一个图像数据存储空间，甚至共享图像存储空间的一部分，如创建<strong>ROI</strong>(Region of Interest)</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="nf">D</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Rect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span> <span class="c1">//矩形ROI</span>
<span class="n">Mat</span> <span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">Range</span><span class="o">:</span><span class="n">all</span><span class="p">(),</span><span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>  <span class="c1">//行列范围ROI</span></code></pre></div>

<p>返回到内存管理问题上，当矩阵数据被多个对象共享时，谁负责释放它？答案是最后一个引用它的对象，这就要用到引用计数机制，<code>Mat</code>类
内设置了一个指向引用计数器的指针<code>refcount</code>,当
一个<code>Mat</code>对象的头部被拷贝时，引用计数器会自增，当一个<code>Mat</code>对象头部被释放时，引用计数器会自减，当计数器清零时矩阵数据被
释放。共享数据存储空间的拷贝称为<strong>软拷贝</strong>。</p>

<p>另外OpenCV提供了<code>clone()</code>和<code>copyTo()</code>方法进行<strong>硬拷贝</strong>，即复制图像的同时复制数据矩阵。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="n">F</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>  <span class="c1">//硬拷贝</span>
<span class="n">Mat</span> <span class="n">G</span><span class="p">;</span>
<span class="n">A</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>    <span class="c1">//硬拷贝</span></code></pre></div>

<h2 id="section-2">类型转换</h2>

<p>同时，OpenCV2提供了将<code>IplImage</code>类型转换为<code>cv::Mat</code>类的方法：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">image4</span><span class="p">(</span><span class="n">iplImage</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span></code></pre></div>

<p>其中默认参数<code>false</code>表示软拷贝，设置为<code>true</code>表示硬拷贝。这时特别需要注意软拷贝时内存管理的问题。
OpenCV2同样提供了对C接口的数据结构进行引用计数的指针类<code>Ptr&lt;IplImage&gt;</code>：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IplImage</span><span class="o">&gt;</span> <span class="n">iplImage</span> <span class="o">=</span> <span class="n">cvLoadImage</span><span class="p">(</span><span class="s">&quot;c:</span><span class="se">\\</span><span class="s">img.jpg&quot;</span><span class="p">);</span></code></pre></div>

<p>这可以规避C API的手动内存管理，但是应该尽量使用OpenCV2提供的C++ API <code>cv::Mat</code>类。</p>

<h2 id="section-3">引用计数注意事项</h2>

<p>引用计数规则允许函数返回<code>Mat</code>类型,例如：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// create image</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">ima</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span><span class="mi">320</span><span class="p">,</span><span class="n">CV_8U</span><span class="p">,</span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="c1">// return it</span>
    <span class="k">return</span> <span class="n">ima</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//get a gray-level image</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">gray</span> <span class="o">=</span><span class="n">function</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>

<p>在主函数内调用函数<code>function()</code>后，<code>gray</code>存储了返回的图像，虽然在<code>function()</code>
执行完毕后局部变量<code>ima</code>会被释放，但是仍存在<code>gray</code>对数据空间的引用，故图像
对应的内存空间并不会被释放。</p>

<p>然而，应当注意<strong>不能</strong>直接返回<code>Mat</code>类型的类属性，如下典型错误示例：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="c1">//image attribute</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">ima</span><span class="p">;</span>

    <span class="nl">public:</span>
        <span class="c1">//constructor creating a gray-level image</span>
        <span class="n">Test</span><span class="p">()</span>  <span class="o">:</span>   <span class="n">ima</span><span class="p">)(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="p">{}</span>
        <span class="c1">//method return a class attribute, not a good idea...</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">method</span><span class="p">()</span>    <span class="p">{</span><span class="k">return</span> <span class="n">ima</span><span class="p">;}</span>
<span class="p">}</span></code></pre></div>

<p>如果调用类方法<code>method()</code>进行赋值操作，变量将创建类属性<code>ima</code>的软拷贝，如果
这个变量在之后被修改，类属性同样会被修改，从而造成类行为的变化。为了避免
这个问题，<strong>总是</strong>创建类属性的硬拷贝。不难发现，这是由于<strong>类</strong>和<strong>函数</strong>的
作用机制上的区别造成的。</p>

<h1 id="io">图像I/O</h1>
<p>OpenCV将包括图像输入/存储/输出等功能封装进<code>core</code>模块中，使用前需要包含头文件：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;opencv2/core/core.hpp&gt;</span></code></pre></div>

<h2 id="section-4">构造函数</h2>
<p>首先看看一种常见的<code>Mat()</code>构造函数<sup id="fnref:matcons"><a href="#fn:matcons" class="footnote">2</a></sup>：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span><span class="o">::</span><span class="n">Mat</span><span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span></code></pre></div>

<p>很容易看出参数意义：</p>

<ul>
  <li>rows: 2维图像矩阵行数</li>
  <li>cols: 2维图像矩阵列数</li>
  <li>type: 矩阵类型</li>
  <li>Scalar&amp; s: 初始化参数</li>
</ul>

<p>OpenCV2在创建<code>cv::Mat</code>对象时可指定图像尺寸以及存储方式，如：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">ima</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span><span class="mi">320</span><span class="p">,</span><span class="n">CV_8UC3</span><span class="p">,</span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span></code></pre></div>

<p>其中前两个参数表示尺寸，<code>CV_8U</code>中<code>8</code>表示采用8位来存储一个像素强度，也可指定为<code>16</code>甚至是<code>32</code>，<code>U</code>表示用无符号类型，
也可以使用带符号类型<code>S</code>或浮点类型<code>F</code>(<code>32F</code>或<code>64F</code>)，<code>C3</code>表示采用三个通道(处理彩色图像)。总结起来，矩阵类型特定的语法规则如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">CV_</span><span class="p">[</span><span class="n">The</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">bite</span> <span class="n">per</span> <span class="n">item</span><span class="p">][</span><span class="n">Signed</span> <span class="n">or</span> <span class="n">Unsigned</span><span class="p">][</span><span class="n">Type</span> <span class="n">Profix</span><span class="p">]</span><span class="n">C</span><span class="p">[</span><span class="n">The</span> <span class="n">Channel</span> <span class="n">number</span><span class="p">]</span></code></pre></div>

<p>需要注意，Mat作为图像容器表现优秀，同时，当其作为一个通用矩阵类时，也可用于创建和处理多维矩阵。但更多的时候，我们只需要采用
<code>Mat varname</code>来创建一个图像容器。</p>

<h2 id="section-5">输入图像</h2>
<p>OpenCV采用<code>imread()</code>函数来输入图像。其C++接口如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="n">imread</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span></code></pre></div>

<p><code>filename</code>为文件名及其路径，可使用绝对路径和相对路径，视应用场景而定。<code>flags</code>指定加载图像的色彩方式：</p>

<ul>
  <li>CV_LOAD_IMAGE_ANYDEPTH : 输入图像采用16位/32位编码是返回16位/32位编码方式，否则转换为8位编码</li>
  <li>CV_LOAD_IMAGE_COLOR : 默认载入彩色图像</li>
  <li>CV_LOAD_IMAGE_GRAYSCALE ： 默认转换为灰度图像</li>
  <li>大于0 : 返回3通道图像</li>
  <li>等于0 : 返回灰度图像</li>
  <li>小于0 : 保留原始图像通道数</li>
</ul>

<p>从前面<code>Mat</code>类定义里可以找到成员变量<code>data</code>，当成功读取图像时，它指向数据空间地址，当读取错误时，对其赋值<code>0</code>，
于是可以采用下面的方法验证图像是否被正确读入并进行相应处理：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle the failure</span>
<span class="p">}</span></code></pre></div>

<p>更多输入图像的细节包括支持的图像格式等请参考<a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html?highlight=imread#imread">imread文档</a>。</p>

<h2 id="section-6">输出图像</h2>
<p>OpenCV采用<code>imwrite()</code>来输出图像到文件，其接口如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="n">imwrite</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">img</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">params</span><span class="o">=</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span></code></pre></div>

<p>除了需要指定输出文件名<code>filename</code>和需要保存的图像矩阵<code>img</code>外，<code>params</code>根据输出文件名后缀类型决定输出文件的质量和压缩比等，详细请参考<a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html?highlight=imwrite#imwrite">imwrite文档</a>。</p>

<h2 id="section-7">显示图像</h2>
<p>将读入的图像显示到屏幕虽然对计算机没什么用，但是方便编程人员直观地评估结果和调试。OpenCV将
可视化功能封装在<code>highgui</code>模块中，使用时需要包含头文件：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;opencv2/highgui/highgui.hpp&gt;</span></code></pre></div>

<p>OpenCV显示图像前需要采用<code>namedWindow()</code>创建窗口。<code>namedWindow()</code>的接口如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">namedWindow</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">winname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="n">WINDOW_AUTOSIZE</span> <span class="p">)</span></code></pre></div>

<p><code>winname</code>为窗口ID，<code>flags</code>支持<code>WINDOW_NORMAL</code>(可缩放)，<code>WINDOW_AUTOSIZE</code>(自适应)，<code>WINDOW_OPENGL</code>(OpenGL)。</p>

<p>创建了窗口后，可采用<code>imshow()</code>函数将图像输出到显示器，使用方式如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">imshow</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">winname</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">mat</span><span class="p">)</span></code></pre></div>

<p>一个完整的窗口创建和图像显示示例如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">namedWindow</span><span class="p">(</span><span class="s">&quot;Output Image&quot;</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Output Image&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span></code></pre></div>

<p>常用于管理窗口显示的函数是<code>int waitKey(int delay=0)</code>，当传递参数大于零时，等待指定毫秒后关闭窗口，若小于等于零，一直保持窗口，
返回值为监听到的按键码。在激活窗口后使用<code>waitKey(0);</code>可使窗口在监听到回车按下时关闭。</p>
<div class="footnotes">
  <ol>
    <li id="fn:stdmat">
      <p>OpenCV2的<code>Mat</code>支持标准I/O，可读入一副图像到<code>image</code>变量，然后使用<code>std::cout &lt;&lt; image &lt;&lt; endl;</code>一探究竟。 <a href="#fnref:stdmat" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:matcons">
      <p>完整的构造函数列表参考文档<a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=mat#Mat::Mat()">Basic Structures</a>部分。 <a href="#fnref:matcons" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#OpenCV" title="Pages tagged OpenCV" class="tag">OpenCV</a><a href="http://localhost:4000/tags/#Computer Visions" title="Pages tagged Computer Visions" class="tag">Computer Visions</a></span>
        
            <div style="text-align:center; width:220px; margin-left:auto; margin-right:auto;">
            <span class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
            </span>
            </div><!-- /.social-share -->
        
      </footer>
        <!-- 社交化评论 -->
        
            <!-- UY BEGIN -->
            <div id="uyan_frame"></div>
            <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1955791"></script>
            <!-- UY END -->
        
    </div><!-- /.entry-content -->
    
        <div class="read-more">
    <div class="read-more-header">
      <a href="http://localhost:4000/blog/posts" class="read-more-btn">更多文章</a>
    </div><!-- /.read-more-header -->
    <hr>
    
      <div align="left">
        <h4><a href="http://localhost:4000/blog/homogeneous/" title="关于齐次坐标系的入门级思考">关于齐次坐标系的入门级思考</a></h4>
      </div><!-- /.list-item -->
    
      <div align="left">
        <h4><a href="http://localhost:4000/blog/opencv2linux/" title="快速开始学习OpenCV">快速开始学习OpenCV</a></h4>
      </div><!-- /.list-item -->
    
      <div align="left">
        <h4><a href="http://localhost:4000/blog/opencv2install/" title="在Ubuntu中安装OpenCV2">在Ubuntu中安装OpenCV2</a></h4>
      </div><!-- /.list-item -->
    
      <div align="left">
        <h4><a href="http://localhost:4000/blog/how-to-read-a-paper/" title="How To Read A Paper">How To Read A Paper</a></h4>
      </div><!-- /.list-item -->
    
      <div align="left">
        <h4><a href="http://localhost:4000/blog/hognote/" title="HOG/linSVM行人检测器：OpenCV+SVMLight实现">HOG/linSVM行人检测器：OpenCV+SVMLight实现</a></h4>
      </div><!-- /.list-item -->
    
    <hr>
    <div class="read-more-header">
      <a href="http://localhost:4000/blog/opencv2linux/" class="read-more-btn">手气不错</a>
    </div><!-- /.read-more-header -->
</div><!-- /.read-more -->

    
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2014 OnceMore. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49487364-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>


</body>
</html>
