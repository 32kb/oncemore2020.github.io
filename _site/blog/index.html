<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>西郊书院 &#8211; OnceMore</title>
<meta name="description" content="Describe this nonsense.">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="西郊书院">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="http://localhost:4000/blog/index.html">
<meta property="og:site_name" content="OnceMore">

<meta name="google-site-verification" content="i2ojlx9jpDBBAKREtMe5JMN1DCdIAlO97Qrf4vOuFF4">



<link rel="canonical" href="http://localhost:4000/blog/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="OnceMore Feed">
<link rel="author" href="https://google.com/https://plus.google.com/110411659539252839234?rel=author">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/blog">博客</a></li>
		<li><a href="http://localhost:4000">主页</a></li>
		<li><a href="http://localhost:4000/blog/about/">关于博客</a></li>
		<li>
			<a href="#">文章目录</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/blog/posts/">所有文章</a></li>
				<li><a href="http://localhost:4000/blog/tags/">所有标签</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-7.jpg" alt="西郊书院">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>西郊书院</h1>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2014-11-05T00:00:00+08:00"><a href="http://localhost:4000/blog/opencv2scan/">November 05, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About OnceMore">OnceMore</a></span></span>
      
      <span class="entry-reading-time pull-right">
        <i class="fa fa-clock-o"></i>
        
        Reading time ~1 minute
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/blog/opencv2scan/" rel="bookmark" title="OpenCV2访问像素值的几种方法" itemprop="url">OpenCV2访问像素值的几种方法</a></h1>
    
  </header>
  <div class="entry-content">
    <p>进行空域处理的第一步就是要访问图像某个位置的像素值，OpenCV2提供了几种访问图像像素的方法，
主要包括随机访问稀疏位置集合和遍历图像大面积连续区域(甚至整幅图像)像素两类模式，
本文对几种常用的方法进行总结。</p>

<p><strong>GOALS</strong>:</p>

<ul>
  <li>随机访问像素</li>
  <li>遍历区域像素
    <ul>
      <li>实例：色彩空间压缩</li>
      <li>采用指针访问</li>
      <li>采用迭代器访问</li>
    </ul>
  </li>
  <li>哪种方法更高效？</li>
</ul>

<p><strong>Reference</strong>:</p>

<p><em>《OpenCV 2 Computer Vision Application Programming Cookbook》- Chapter 2</em></p>

<h1 id="section">1.随机访问像素</h1>

<h2 id="section-1">1.1 实例:椒盐噪声</h2>

<h2 id="section-2">1.2 方法</h2>

<h1 id="section-3">2.遍历区域像素</h1>

<h2 id="section-4">2.1实例:色彩空间压缩</h2>

<h2 id="section-5">2.2采用指针</h2>

<h2 id="section-6">2.3采用迭代器</h2>

<h1 id="section-7">3.性能比较</h1>

<h2 id="section-8">3.1计时方法</h2>

<h2 id="section-9">3.2对比结果</h2>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2014-09-19T00:00:00+08:00"><a href="http://localhost:4000/blog/homogeneous/">September 19, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About OnceMore">OnceMore</a></span></span>
      
      <span class="entry-reading-time pull-right">
        <i class="fa fa-clock-o"></i>
        
        Reading time ~2 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/blog/homogeneous/" rel="bookmark" title="关于齐次坐标系的入门级思考" itemprop="url">关于齐次坐标系的入门级思考</a></h1>
    
  </header>
  <div class="entry-content">
    <p>今天看计算机视觉方面的资料时遇到了关于<strong>齐次坐标系(Homogeneous Coordinates)</strong>的问题，
于是翻阅资料进行了浅显的一些了解，这里记下一些总结出来的思考。</p>

<h1 id="section">初步了解</h1>

<h2 id="section-1">齐次坐标的引入</h2>
<p>在欧式空间里，两条共面的平行线无法相交，然而在<strong>投影空间(Projective Space)</strong>内却不是这样，
一个感性的理解是，如下图中的两条铁轨的间距随着视线变远而减小，直至在地平线处(无限远点)相交。</p>

<p><img src="/images/homogeneous/railway.jpg" alt="RailWay" /></p>

<p>欧式空间采用<script type="math/tex">(x,y,z)</script>来表示一个三维点，但是无穷远点<script type="math/tex">(\infty,\infty,\infty)</script>在欧式空间里是没有意义的,
但是在投影空间中进行图形和几何运算并不是一个简单的问题，为了解决这个问题，
数学家August Ferdinand Möbius(大概每个中国人都知道的莫比乌斯)提出了齐次坐标系，采用N+1个量来表示N维坐标。
例如，在二维齐次坐标系中，我们引入一个量<script type="math/tex">w</script>,将一个二维点<script type="math/tex">(x,y)</script>表示为<script type="math/tex">(X,Y,w)</script>的形式，其转换关系是</p>

<script type="math/tex; mode=display">
\begin{array}{l}
x=\frac{X}{w}\\
y=\frac{Y}{w}
\end{array}
</script>

<p>例如，在欧式坐标中的一个二维点<script type="math/tex">(1,2)</script>可以在齐次坐标中表示为<script type="math/tex">(1,2,1)</script>，如果点逐渐移动向无穷远处，
其欧式坐标变为<script type="math/tex">(\infty,\infty)</script>，而齐次坐标变为<script type="math/tex">(1,2,0)</script>，注意到在齐次坐标下不需要<script type="math/tex">\infty</script>就可以表示无限远处的点。</p>

<h2 id="section-2">“齐次”之名由何而来？</h2>

<p>如果我们要将欧式坐标的一个二维点<script type="math/tex">(1,2)</script>转换为齐次坐标，根据规则，我们可以选择刚才用到的<script type="math/tex">(1,2,1)</script>，也可以
选择<script type="math/tex">(2,4,2)</script>，还可以选择<script type="math/tex">(4,8,4),(8,16,8)...</script>，即<script type="math/tex">(k,2k,k),k\in\mathbb{R}</script>都是“合法”的齐次坐标表示，这些
点都映射到欧式空间中的一点，即这些点具有<strong>尺度不变性(Scale Invariant)</strong>，是”齐性的”(同族的)，所以称之为齐次坐标。</p>

<h2 id="section-3">一个不太严格的证明两条平行线可以相交</h2>

<p>考虑两条平行线：</p>

<script type="math/tex; mode=display">
\left\{ \begin{array}{l}
Ax+By+C=0\\
Ax+By+D=0
\end{array} \right.
</script>

<p>在欧式空间中，<script type="math/tex">C=D</script>时两条线重合，否则不相交。尝试用<script type="math/tex">\frac{x}{w},\frac{y}{w}</script>替换<script type="math/tex">x,y</script>
(如前面提到的，用N+1个量表示N维坐标，这里增加了一个量<script type="math/tex">w</script>)，可以得到：</p>

<script type="math/tex; mode=display">
\left\{ \begin{array}{l}
Ax+By+Cw=0\\
Ax+By+Dw=0
\end{array} \right.
</script>

<p>可以得到解<script type="math/tex">(x,y,0)</script>，即两条平行线在<script type="math/tex">(x,y,0)</script>处相遇，称之为无穷点(注意这里不要用欧式空间的思维去想象这个点在哪里)。</p>

<h2 id="section-4">重要性</h2>

<p>《计算机图形学(OpenGL版)》的作者F.S. Hill Jr.曾说过一句话：</p>

<blockquote>
  <p>“齐次坐标表示是计算机图形学的重要手段之一，它既能够用来明确区分向量和点，同时也更易用于进行仿射（线性）几何变换。”</p>
</blockquote>

<p>于是我们知道，其重要性，主要有二，其一时区分向量和点，其二是易于进行<strong>仿射变化(Affine Transformation)</strong>，
但是这两点内部的原因又是什么呢？吹牛逼要吹到家，总不能说是大牛说的就是对的吧，要理解这两点，需要进行更细致一些的了解，请往下看。</p>

<h1 id="section-5">深入理解</h1>

<p>首先，我们需要对齐次坐标系的形式化表达更明了，为了简化，主要以2维点做之后的说明。</p>

<h3 id="section-6">2维点</h3>

<p>欧式坐标表示：</p>

<script type="math/tex; mode=display">\textbf{x}=(x,y) \in \mathbb{R}^2</script>

<p>齐次坐标表示：</p>

<script type="math/tex; mode=display">\tilde{x}=(\hat{x},\hat{y},w) \in \mathbb{P}^2 </script>

<p><script type="math/tex">w=0</script>时称为<strong>无穷点(points at infinity)</strong>，其中<script type="math/tex">\mathbb{P}^2=\mathbb{R}^3-(0,0,0)</script>为<strong>2D投影空间</strong>。<strong>齐次矢量</strong><script type="math/tex">\tilde{x}</script>可转换为欧式表示：</p>

<script type="math/tex; mode=display">\tilde{x}=(\hat{x},\hat{y},w)=w(x,y,1)=w\bar{\textbf{x}}</script>

<p><script type="math/tex">\bar{\textbf{x}}</script>称为<strong>增广矢量(augmented vector)</strong>。</p>

<h3 id="section-7">2维线</h3>

<p>齐次表示：</p>

<script type="math/tex; mode=display">\tilde{l}=(a,b,c)</script>

<p>对应欧式空间直线方程：</p>

<script type="math/tex; mode=display">\bar{\textbf{x}}\cdot\tilde{l}=ax+by+c=0</script>

<p>例外是在<script type="math/tex">\tilde{l}=(0,0,1)</script>时为<strong>无穷线</strong>，包含了所有的2维无穷点。</p>

<p>可将<script type="math/tex">\tilde{l}</script>标准化为<script type="math/tex">l=(\hat{n}_x,\hat{n}_y,d)=(\hat{\textbf{n}},d),\parallel\hat{\textbf{n}}\parallel=1</script>,
<script type="math/tex">\hat{\textbf{n}}</script>称为<strong>标准化矢量</strong>，与直线<script type="math/tex">\tilde{l}</script>垂直，<script type="math/tex">d</script>为原点到直线的距离，下图给出了比较形象的解释：</p>

<p><img src="\images\homogeneous\2dline.png" alt="2D line" /></p>

<p>采用齐次坐标系时，可求得两条直线的交点的齐次表达：</p>

<script type="math/tex; mode=display">\tilde{x}=\tilde{l}_1\times\tilde{l}_2</script>

<p><script type="math/tex">\times</script>表示叉积。同时，两个点确定的直线方程的齐次表达为：</p>

<script type="math/tex; mode=display">\tilde{l}=\tilde{x}_1\times\tilde{x}_2</script>

<p>以上结论的严格的证明是很容易的，最粗暴简单的思路就是在欧式空间内计算出结果后转化为齐次表达，并与采用齐次表达计算结果进行对比，
这里略过。</p>

<h2 id="section-8">为什么更易用于仿射变换？</h2>

<p>对于一个2维点<script type="math/tex">p=(x,y)</script>，仿射变换(T)是线性变换(Ap)和平移变换(+t)的叠加:</p>

<script type="math/tex; mode=display">
T(p)=Ap+t
</script>

<p>线性变换在欧式空间中可以表示为矩阵乘积形式，如旋转变换和缩放变换：</p>

<script type="math/tex; mode=display">% <![CDATA[

\left[ \begin{array}{l}
\grave{x}\\
\grave{y}
\end{array} \right]=
\left[ \begin{array}{cc}
cos(\theta) & -sin(\theta)\\
sin(\theta) & cos(\theta)
\end{array}
\right]
\left[ \begin{array}{l}
x\\
y
\end{array}
\right]
 %]]></script>

<script type="math/tex; mode=display">% <![CDATA[

\left[ \begin{array}{l}
\grave{x}\\
\grave{y}
\end{array} \right]=
\left[ \begin{array}{cc}
S_x & 0\\
0 & S_y
\end{array}
\right]
\left[ \begin{array}{l}
x\\
y
\end{array}
\right]
 %]]></script>

<p>而平移变换</p>

<script type="math/tex; mode=display">
\left[ \begin{array}{l}
\grave{x}\\
\grave{y}
\end{array} \right]=
\left[ \begin{array}{c}
x\\
y
\end{array}
\right]
+\left[ \begin{array}{l}
t_x\\
t_y
\end{array}
\right]
</script>

<p>却不能用矩阵相乘的形式表达。现在引入齐次坐标系表达<script type="math/tex">\tilde{p}=(x,y,1)</script>，(尺度不变性，实际上在高一维的空间映射到<script type="math/tex">w=1</script>平面, 这样计算后结果直接可导出到欧式空间)。可以将旋转变换和尺度变换表示为： </p>

<script type="math/tex; mode=display">% <![CDATA[

\left[ \begin{array}{l}
\grave{x}\\
\grave{y}\\
1
\end{array} \right]=
\left[ \begin{array}{ccc}
cos(\theta) & -sin(\theta) & 0 \\
sin(\theta) & cos(\theta) & 0 \\
0 & 0 & 1
\end{array}
\right]
\left[ \begin{array}{l}
x\\
y\\
1
\end{array}
\right]
 %]]></script>

<script type="math/tex; mode=display">% <![CDATA[

\left[ \begin{array}{l}
\grave{x}\\
\grave{y}\\
1
\end{array} \right]=
\left[ \begin{array}{ccc}
S_x & 0 & 0\\
0 & S_y & 0\\
0 & 0 & 1
\end{array}
\right]
\left[ \begin{array}{l}
x\\
y\\
1
\end{array}
\right]
 %]]></script>

<p>平移变换表示为：</p>

<script type="math/tex; mode=display">% <![CDATA[

\left[ \begin{array}{l}
\grave{x}\\
\grave{y}\\
1
\end{array} \right]=
\left[ \begin{array}{ccc}
1 & 0 & t_x\\
0 & 1 & t_y\\
0 & 0 & 1
\end{array}
\right]
\left[ \begin{array}{l}
x\\
y\\
1
\end{array}
\right]
 %]]></script>

<p>然后我们可以导出仿射变换的矩阵形式，</p>

<script type="math/tex; mode=display">% <![CDATA[

T=\left[
\begin{array}{cc}
\textbf{A} & \textbf{t}\\
\textbf{O}_{1\times2} & 1
\end{array}
\right]
\left[ \begin{array}{l}
x\\
y\\
1
\end{array}
\right]
 %]]></script>

<p>其中<script type="math/tex">\textbf{O}_{1\times2}=[0~~0]</script>，仿射变换保留了点的共线/面性质及比例(可以参考一些图形学资料)，这在图形处理中非常重要，比如对于
平面上的一个几何形状进行变换，只需要对其顶点进行变换就可实现(在2维线上的点变换后一定与变换后的端点共线)。而齐次坐标系的
引入使仿射变换能以紧凑统一的矩阵形式表达和计算，这体现了其对仿射变换的重要性。</p>

<h2 id="section-9">为什么能够明确区分向量和点？</h2>

<p>当我们在坐标系<script type="math/tex">xOy</script>中用<script type="math/tex">(a,b)</script>定义一个向量<script type="math/tex">\vec{v}</script>时,表示<script type="math/tex">\vec{v}=a\vec{x}+b\vec{y}</script>，
当我们在同样的坐标系中用<script type="math/tex">(a,b)</script>表示一个点<script type="math/tex">p</script>时，表示<script type="math/tex">p-o=a\vec{x}+b\vec{y}</script>，假若写下<script type="math/tex">(2,1)</script>，
如无附加说明，不能区别出它是向量还是点。将点的表示重写为：</p>

<script type="math/tex; mode=display">
p=[a~~b~~1]\left[
\begin{array}{c}
\vec{x}\\
\vec{y}\\
o
\end{array}
\right]
</script>

<p>将向量的表示写为:</p>

<script type="math/tex; mode=display">
p=[a~~b~~0]\left[
\begin{array}{c}
\vec{x}\\
\vec{y}\\
o
\end{array}
\right]
</script>

<p>这样能够清晰地区分向量和点，用3个量表示2维点，这即是齐次坐标的思想。</p>

<h1 id="section-10">下一步</h1>

<p>文章为了便于思考，讨论的都是简单的情形，还有很多问题都没有严格的证明，比如，
3维点表达是否还适用？面表达，线表达呢？还有仿射变换为什么保留了共线/面信息？
更深入的了解建议找一本计算机图形学的资料，能够了解到更多关于投影空间，2D变换，3D变换，3D到2D变换的形式化表示,
以及更严格的证明和表述。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2014-08-04T00:00:00+08:00"><a href="http://localhost:4000/blog/opencv2basic/">August 04, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About OnceMore">OnceMore</a></span></span>
      
      <span class="entry-reading-time pull-right">
        <i class="fa fa-clock-o"></i>
        
        Reading time ~4 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/blog/opencv2basic/" rel="bookmark" title="OpenCV2 基础操作" itemprop="url">OpenCV2 基础操作</a></h1>
    
  </header>
  <div class="entry-content">
    <p>快速了解OpenCV2基础操作，对于系统地开始阅读和学习文档有很大帮助。</p>

<h1 id="mat">Mat数据结构</h1>
<p>将获取的图像转码到数字设备时，采用一张数表(矩阵)来存储图像的每一像素强度<sup id="fnref:stdmat"><a href="#fn:stdmat" class="footnote">1</a></sup>。如下图所示，每个位置的数字表示当前位置的像素强度。</p>

<p><img src="/images/opencv2basic/mat.jpg" alt="Mat Demo" /></p>

<p>具体如何存储和获取这些像素值取决于具体需求，但是最终计算机内的所有的图像都是用各种矩阵来描述的。
OpenCV2采用<code>cv::Mat</code>类来存储图像，OpenCV2提供的C++ API中定义的类和函数都定义在命名空间<code>cv</code>中，可用如下方式声明:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span></code></pre></div>

<p>创建一个变量来存储图像：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">image</span><span class="p">;</span></code></pre></div>

<h2 id="section">存储方法</h2>
<p>存储像素值来表示图像涉及到<strong>色彩空间</strong>和<strong>数据类型</strong>。<strong>色彩空间</strong>是使用一组值来表示图像色彩的数学模型，最简单的是<strong>灰度值图像</strong>，处理的
颜色都是黑白的。对于彩色图像，可将每一个像素分解为若干个色彩成分通道，最流行的方式是<strong>RGB</strong>，因为人眼就是这样构建色彩世界的，三基色
为红，绿，蓝。有时会采用其它色彩空间，其对比如下：</p>

<ul>
  <li>RGB：最常见的色彩系统，用红绿蓝三色光的比例叠加来表示颜色，与人眼视觉系统原理类似，通常的显示系统也有采用这种色彩系统；</li>
  <li>HSV/HLS：将色彩分解为色调，饱和度，强度/亮度等元素，这种描述更自然直观，艺术家常用的色彩空间；</li>
  <li>CMYK : 使用青，品红，黄，黑四种油墨叠加在白色纸张上来体现彩色图像，常见于打印设备</li>
</ul>

<p>现实世界的像素强度值是连续的，而计算机只能直接对离散数据进行处理，因此需要将像素强度进行<strong>量化</strong>为离散数值，用相应<strong>数据类型</strong>存储，常采用与<code>char</code>数据
类型相同的数据空间：1字节或8比特，对应十进制为无符号(0~255)/带符号(-127~+127)。可以采用更大的数据类型来存储，会带来图像存储空间
的增长。</p>

<h2 id="opencv">OpenCV图像存储数据结构历史</h2>
<p>OpenCV诞生于2001年，最初版本运算库是基于C接口设计的，采用的C数据结构<code>IplImage</code>来存储图像，此方法引入了所有的C缺陷，其中最
主要的问题是手动管理内存，要求用户负责内存的分配和释放，这种情况在较小型的程序设计中影响并不大，当设计任务增长时用户可能会花
更多的时间来处理内存管理问题。如采用C接口来读入一个图像：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">IplImage</span><span class="o">*</span> <span class="n">iplImage</span> <span class="o">=</span> <span class="n">cvLoadImage</span><span class="p">(</span><span class="s">&quot;c:</span><span class="se">\\</span><span class="s">img.jpg&quot;</span><span class="p">);</span></code></pre></div>

<p>当不再使用变量时需要手动释放内存空间:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cvReleaseImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iplImage</span><span class="p">);</span></code></pre></div>

<p>OpenCV2引入了C++接口<code>cv::Mat</code>，当然也包括C++围绕着<strong>类(class)</strong>的设计模式的一种新概念:<strong>自动内存管理</strong>。</p>

<h2 id="section-1">引用计数系统</h2>
<p><code>Mat</code>从类的角度可分为两部分：<strong>矩阵头</strong>(矩阵大小，存储方法，初始地址)和一个指向数据单元的<strong>指针</strong>。矩阵头的大小是固定的，但是矩阵
的大小会随着存储图像的大小而改变。来看看<code>Mat</code>的部分类定义：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Mat</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ... a lot of methods ...</span>
    <span class="p">...</span>

    <span class="cm">/*! includes several bit-fields:</span>
<span class="cm">         - the magic signature</span>
<span class="cm">         - continuity flag</span>
<span class="cm">         - depth</span>
<span class="cm">         - number of channels</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//! the array dimensionality, &gt;= 2</span>
    <span class="kt">int</span> <span class="n">dims</span><span class="p">;</span>
    <span class="c1">//! the number of rows and columns or (-1, -1) when the array has more than 2 dimensions</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">;</span>
    <span class="c1">//! pointer to the data</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

    <span class="c1">//! pointer to the reference counter;</span>
    <span class="c1">// when array points to user-allocated data, the pointer is NULL</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">refcount</span><span class="p">;</span>

    <span class="c1">// other members</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre></div>

<p>当设定一个处理任务时，系统输入图像需要通过<code>Mat</code>传递，图像处理的计算量是庞大的，在传递
图像时我们不能随意地创建不必要的图像拷贝，因为这会影响程序的效率。为了解决这个问题，OpenCV采用<strong>引用计数系统(Reference Counting System)</strong>
，主要思想是每个矩阵对象采用各自的矩阵头，但是矩阵的数据存储单元能被多个对象共享。这样在拷贝操作时只需要拷贝矩阵头和指针
即可，不会拷贝存储单元数据。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">;</span>   <span class="c1">//只创建矩阵头</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">CV_LOAD_IMAGE_COLOR</span><span class="p">);</span>   <span class="c1">//分配存储单元</span>
<span class="n">Mat</span> <span class="nf">B</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>   <span class="c1">//拷贝操作(通过构造函数)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>  <span class="c1">//赋值操作</span></code></pre></div>

<p>以上示例代码中<code>A</code>,<code>B</code>,<code>C</code>最终都只指向同一个矩阵数据，但是它们的矩阵头不一样，所以修改其中任何一个对象都会影响其它对象。
实际应用中常采用这种方式，不同的对象共享一个图像数据存储空间，甚至共享图像存储空间的一部分，如创建<strong>ROI</strong>(Region of Interest)</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="nf">D</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Rect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span> <span class="c1">//矩形ROI</span>
<span class="n">Mat</span> <span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">Range</span><span class="o">:</span><span class="n">all</span><span class="p">(),</span><span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>  <span class="c1">//行列范围ROI</span></code></pre></div>

<p>返回到内存管理问题上，当矩阵数据被多个对象共享时，谁负责释放它？答案是最后一个引用它的对象，这就要用到引用计数机制，<code>Mat</code>类
内设置了一个指向引用计数器的指针<code>refcount</code>,当
一个<code>Mat</code>对象的头部被拷贝时，引用计数器会自增，当一个<code>Mat</code>对象头部被释放时，引用计数器会自减，当计数器清零时矩阵数据被
释放。共享数据存储空间的拷贝称为<strong>软拷贝</strong>。</p>

<p>另外OpenCV提供了<code>clone()</code>和<code>copyTo()</code>方法进行<strong>硬拷贝</strong>，即复制图像的同时复制数据矩阵。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="n">F</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>  <span class="c1">//硬拷贝</span>
<span class="n">Mat</span> <span class="n">G</span><span class="p">;</span>
<span class="n">A</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>    <span class="c1">//硬拷贝</span></code></pre></div>

<h2 id="section-2">类型转换</h2>

<p>同时，OpenCV2提供了将<code>IplImage</code>类型转换为<code>cv::Mat</code>类的方法：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">image4</span><span class="p">(</span><span class="n">iplImage</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span></code></pre></div>

<p>其中默认参数<code>false</code>表示软拷贝，设置为<code>true</code>表示硬拷贝。这时特别需要注意软拷贝时内存管理的问题。
OpenCV2同样提供了对C接口的数据结构进行引用计数的指针类<code>Ptr&lt;IplImage&gt;</code>：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IplImage</span><span class="o">&gt;</span> <span class="n">iplImage</span> <span class="o">=</span> <span class="n">cvLoadImage</span><span class="p">(</span><span class="s">&quot;c:</span><span class="se">\\</span><span class="s">img.jpg&quot;</span><span class="p">);</span></code></pre></div>

<p>这可以规避C API的手动内存管理，但是应该尽量使用OpenCV2提供的C++ API <code>cv::Mat</code>类。</p>

<h2 id="section-3">引用计数注意事项</h2>

<p>引用计数规则允许函数返回<code>Mat</code>类型,例如：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// create image</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">ima</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span><span class="mi">320</span><span class="p">,</span><span class="n">CV_8U</span><span class="p">,</span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="c1">// return it</span>
    <span class="k">return</span> <span class="n">ima</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//get a gray-level image</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">gray</span> <span class="o">=</span><span class="n">function</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>

<p>在主函数内调用函数<code>function()</code>后，<code>gray</code>存储了返回的图像，虽然在<code>function()</code>
执行完毕后局部变量<code>ima</code>会被释放，但是仍存在<code>gray</code>对数据空间的引用，故图像
对应的内存空间并不会被释放。</p>

<p>然而，应当注意<strong>不能</strong>直接返回<code>Mat</code>类型的类属性，如下典型错误示例：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="c1">//image attribute</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">ima</span><span class="p">;</span>

    <span class="nl">public:</span>
        <span class="c1">//constructor creating a gray-level image</span>
        <span class="n">Test</span><span class="p">()</span>  <span class="o">:</span>   <span class="n">ima</span><span class="p">)(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="p">{}</span>
        <span class="c1">//method return a class attribute, not a good idea...</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">method</span><span class="p">()</span>    <span class="p">{</span><span class="k">return</span> <span class="n">ima</span><span class="p">;}</span>
<span class="p">}</span></code></pre></div>

<p>如果调用类方法<code>method()</code>进行赋值操作，变量将创建类属性<code>ima</code>的软拷贝，如果
这个变量在之后被修改，类属性同样会被修改，从而造成类行为的变化。为了避免
这个问题，<strong>总是</strong>创建类属性的硬拷贝。不难发现，这是由于<strong>类</strong>和<strong>函数</strong>的
作用机制上的区别造成的。</p>

<h1 id="io">图像I/O</h1>
<p>OpenCV将包括图像输入/存储/输出等功能封装进<code>core</code>模块中，使用前需要包含头文件：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;opencv2/core/core.hpp&gt;</span></code></pre></div>

<h2 id="section-4">构造函数</h2>
<p>首先看看一种常见的<code>Mat()</code>构造函数<sup id="fnref:matcons"><a href="#fn:matcons" class="footnote">2</a></sup>：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span><span class="o">::</span><span class="n">Mat</span><span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span></code></pre></div>

<p>很容易看出参数意义：</p>

<ul>
  <li>rows: 2维图像矩阵行数</li>
  <li>cols: 2维图像矩阵列数</li>
  <li>type: 矩阵类型</li>
  <li>Scalar&amp; s: 初始化参数</li>
</ul>

<p>OpenCV2在创建<code>cv::Mat</code>对象时可指定图像尺寸以及存储方式，如：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">ima</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span><span class="mi">320</span><span class="p">,</span><span class="n">CV_8UC3</span><span class="p">,</span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span></code></pre></div>

<p>其中前两个参数表示尺寸，<code>CV_8U</code>中<code>8</code>表示采用8位来存储一个像素强度，也可指定为<code>16</code>甚至是<code>32</code>，<code>U</code>表示用无符号类型，
也可以使用带符号类型<code>S</code>或浮点类型<code>F</code>(<code>32F</code>或<code>64F</code>)，<code>C3</code>表示采用三个通道(处理彩色图像)。总结起来，矩阵类型特定的语法规则如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">CV_</span><span class="p">[</span><span class="n">The</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">bite</span> <span class="n">per</span> <span class="n">item</span><span class="p">][</span><span class="n">Signed</span> <span class="n">or</span> <span class="n">Unsigned</span><span class="p">][</span><span class="n">Type</span> <span class="n">Profix</span><span class="p">]</span><span class="n">C</span><span class="p">[</span><span class="n">The</span> <span class="n">Channel</span> <span class="n">number</span><span class="p">]</span></code></pre></div>

<p>需要注意，Mat作为图像容器表现优秀，同时，当其作为一个通用矩阵类时，也可用于创建和处理多维矩阵。但更多的时候，我们只需要采用
<code>Mat varname</code>来创建一个图像容器。</p>

<h2 id="section-5">输入图像</h2>
<p>OpenCV采用<code>imread()</code>函数来输入图像。其C++接口如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Mat</span> <span class="n">imread</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span></code></pre></div>

<p><code>filename</code>为文件名及其路径，可使用绝对路径和相对路径，视应用场景而定。<code>flags</code>指定加载图像的色彩方式：</p>

<ul>
  <li>CV_LOAD_IMAGE_ANYDEPTH : 输入图像采用16位/32位编码是返回16位/32位编码方式，否则转换为8位编码</li>
  <li>CV_LOAD_IMAGE_COLOR : 默认载入彩色图像</li>
  <li>CV_LOAD_IMAGE_GRAYSCALE ： 默认转换为灰度图像</li>
  <li>大于0 : 返回3通道图像</li>
  <li>等于0 : 返回灰度图像</li>
  <li>小于0 : 保留原始图像通道数</li>
</ul>

<p>从前面<code>Mat</code>类定义里可以找到成员变量<code>data</code>，当成功读取图像时，它指向数据空间地址，当读取错误时，对其赋值<code>0</code>，
于是可以采用下面的方法验证图像是否被正确读入并进行相应处理：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle the failure</span>
<span class="p">}</span></code></pre></div>

<p>更多输入图像的细节包括支持的图像格式等请参考<a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html?highlight=imread#imread">imread文档</a>。</p>

<h2 id="section-6">输出图像</h2>
<p>OpenCV采用<code>imwrite()</code>来输出图像到文件，其接口如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="n">imwrite</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">img</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">params</span><span class="o">=</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span></code></pre></div>

<p>除了需要指定输出文件名<code>filename</code>和需要保存的图像矩阵<code>img</code>外，<code>params</code>根据输出文件名后缀类型决定输出文件的质量和压缩比等，详细请参考<a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html?highlight=imwrite#imwrite">imwrite文档</a>。</p>

<h2 id="section-7">显示图像</h2>
<p>将读入的图像显示到屏幕虽然对计算机没什么用，但是方便编程人员直观地评估结果和调试。OpenCV将
可视化功能封装在<code>highgui</code>模块中，使用时需要包含头文件：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;opencv2/highgui/highgui.hpp&gt;</span></code></pre></div>

<p>OpenCV显示图像前需要采用<code>namedWindow()</code>创建窗口。<code>namedWindow()</code>的接口如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">namedWindow</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">winname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="n">WINDOW_AUTOSIZE</span> <span class="p">)</span></code></pre></div>

<p><code>winname</code>为窗口ID，<code>flags</code>支持<code>WINDOW_NORMAL</code>(可缩放)，<code>WINDOW_AUTOSIZE</code>(自适应)，<code>WINDOW_OPENGL</code>(OpenGL)。</p>

<p>创建了窗口后，可采用<code>imshow()</code>函数将图像输出到显示器，使用方式如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">imshow</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">winname</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">mat</span><span class="p">)</span></code></pre></div>

<p>一个完整的窗口创建和图像显示示例如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">cv</span><span class="o">::</span><span class="n">namedWindow</span><span class="p">(</span><span class="s">&quot;Output Image&quot;</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Output Image&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span></code></pre></div>

<p>常用于管理窗口显示的函数是<code>int waitKey(int delay=0)</code>，当传递参数大于零时，等待指定毫秒后关闭窗口，若小于等于零，一直保持窗口，
返回值为监听到的按键码。在激活窗口后使用<code>waitKey(0);</code>可使窗口在监听到回车按下时关闭。</p>
<div class="footnotes">
  <ol>
    <li id="fn:stdmat">
      <p>OpenCV2的<code>Mat</code>支持标准I/O，可读入一副图像到<code>image</code>变量，然后使用<code>std::cout &lt;&lt; image &lt;&lt; endl;</code>一探究竟。 <a href="#fnref:stdmat" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:matcons">
      <p>完整的构造函数列表参考文档<a href="http://docs.opencv.org/modules/core/doc/basic_structures.html?highlight=mat#Mat::Mat()">Basic Structures</a>部分。 <a href="#fnref:matcons" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2014-07-31T00:00:00+08:00"><a href="http://localhost:4000/blog/opencv2linux/">July 31, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About OnceMore">OnceMore</a></span></span>
      
      <span class="entry-reading-time pull-right">
        <i class="fa fa-clock-o"></i>
        
        Reading time ~1 minute
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/blog/opencv2linux/" rel="bookmark" title="快速开始学习OpenCV" itemprop="url">快速开始学习OpenCV</a></h1>
    
  </header>
  <div class="entry-content">
    <p>在Linux下安装好OpenCV2后，如何快速开始使用或学习OpenCV是首要问题。如何编译一个采用了OpenCV运算库的程序呢(C/C++)？有下面几种不同的思路：</p>

<ul>
  <li>使用命令行gcc给定编译参数进行编译(复杂度高);</li>
  <li>使用一个IDE，配置头文件和库文件路径，常用的有Eclipse，Code::Blocks，Qt等(复杂度适中);</li>
  <li>使用命令行工程构建工具CMake(清晰明了，复杂度低，易于上手).</li>
</ul>

<p>本文采用最后一种方式，推荐采用Linux作为工作环境，专注于算法理解和学习实现的同学使用。在<a href="http://oncemore2020.github.io/blog/opencv2install/">编译安装OpenCV</a>
的时候已经安装好了CMake以及一系列构建工具，现在介绍如何使用工具包来编译程序。</p>

<h1 id="section">工作目录树</h1>
<p>使用CMake构建工程，工作目录应该具有如下结构：</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">--------------------
    <span class="p">|</span>-CMakeLists.txt
    <span class="p">|</span>-main.cpp
--------------------</code></pre></div>

<p>其中<code>CMakeLists.txt</code>是工程设定文件，稍后深入了解其内容，<code>main.cpp</code>是源程序文件。</p>

<h1 id="cmake">CMake设定</h1>
<p>这里给出一种简单可复制的工程设定文件，在应用到其它源程序时只需要进行少量修改。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">cmake_minimum_required<span class="o">(</span>VERSION 2.8<span class="o">)</span>
project<span class="o">(</span> main <span class="o">)</span>
find_package<span class="o">(</span> OpenCV REQUIRED <span class="o">)</span>
add_executable<span class="o">(</span> main main.cpp <span class="o">)</span>
target_link_libraries<span class="o">(</span> main <span class="k">${</span><span class="nv">OpenCV_LIBS</span><span class="k">}</span> <span class="o">)</span></code></pre></div>

<p>设置文件是很容易理解的，规定了工程文件名，程序包要求，编译源文件名，编译目标可执行文件名，以及链接库对象和库路径。</p>

<h1 id="section-1">源文件</h1>
<p>采用一个简单的程序进行演示，程序用到<code>core.hpp</code>和<code>highgui.hpp</code>头文件，实现读入一个图像，进行水平翻转后输出到文件。代码如下：</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#include &lt;opencv2/core/core.hpp&gt;</span>
<span class="c">#include &lt;opencv2/highgui/highgui.hpp&gt;</span>
<span class="c">#include &lt;iostream&gt;</span>

using namespace cv<span class="p">;</span>
using namespace std<span class="p">;</span>

int main<span class="o">(){</span>
    Mat <span class="nv">image</span> <span class="o">=</span> imread<span class="o">(</span><span class="s2">&quot;test.jpg&quot;</span><span class="o">)</span><span class="p">;</span>
    <span class="k">if</span> <span class="o">(</span> !image.data <span class="o">){</span>
        cout &lt;&lt; <span class="s2">&quot;No image LOADED!&quot;</span> <span class="s">&lt;&lt; endl;</span>
<span class="s">    }</span>
<span class="s">    namedWindow(&quot;Original Image&quot;);</span>
<span class="s">    cout &lt;&lt; &quot;size: &quot; &lt;&lt; image.size().height &lt;&lt; &quot; , &quot;</span>
<span class="s">        &lt;&lt; image.size().width &lt;&lt; endl</span><span class="p">;</span>
    imshow<span class="o">(</span><span class="s2">&quot;Original Image&quot;</span>, image<span class="o">)</span><span class="p">;</span>
    Mat result<span class="p">;</span>
    flip<span class="o">(</span>image, result, 1<span class="o">)</span><span class="p">;</span>     
    namedWindow<span class="o">(</span><span class="s2">&quot;Output Image&quot;</span><span class="o">)</span><span class="p">;</span>
    imshow<span class="o">(</span><span class="s2">&quot;Output Image&quot;</span>, result<span class="o">)</span><span class="p">;</span>
    waitKey<span class="o">(</span>0<span class="o">)</span><span class="p">;</span>
    imwrite<span class="o">(</span><span class="s2">&quot;output.jpg&quot;</span>, result<span class="o">)</span><span class="p">;</span>
    <span class="k">return </span>0<span class="p">;</span>
<span class="o">}</span></code></pre></div>

<h1 id="section-2">构建</h1>
<p>在工作目录里命令行输入以下指令进行构建：</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">cmake .
make</code></pre></div>

<p>构建过程终端输出如图
<img src="/images/opencv2linux/code.png" alt="CLI codes" /></p>

<p>构建完成后则可以运行<code>./test</code>程序，得到想要的结果。
<img src="/images/opencv2linux/out.png" alt="CLI codes" /></p>

<h1 id="section-3">总结</h1>
<p>在学习OpenCV2的过程中，往往是模块化地了解各个库内的接口，这样单一源程序即可完成，所以采用CMake可以快速的尝试新的代码，只需要
复制文件就可以新建一个工程开始试验新的函数功能接口。深入了解CMake，可以参考<a href="http://www.cmake.org/cmake/help/cmake_tutorial.html">CMake指南</a>
,应该已经足够。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2014-07-29T00:00:00+08:00"><a href="http://localhost:4000/blog/opencv2install/">July 29, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About OnceMore">OnceMore</a></span></span>
      
      <span class="entry-reading-time pull-right">
        <i class="fa fa-clock-o"></i>
        
        Reading time ~1 minute
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/blog/opencv2install/" rel="bookmark" title="在Ubuntu中安装OpenCV2" itemprop="url">在Ubuntu中安装OpenCV2</a></h1>
    
  </header>
  <div class="entry-content">
    <p>在Ubuntu 12.04 LTS 版本下安装成功且正常使用了很长时间，在Ubuntu 14.04 LTS 版本下安装成功但是没有长期使用，不过应该没有问题。</p>

<h1 id="section">安装开发构建工具</h1>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install build-essential cmake pkg-config</code></pre></div>

<h1 id="io">安装图像I/O库</h1>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install libjpeg62-dev
sudo apt-get -y install libtiff4-dev libjasper-dev</code></pre></div>

<h1 id="gtk">安装GTK开发库</h1>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install  libgtk2.0-dev</code></pre></div>

<h1 id="io-1">安装视频I/O库</h1>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev</code></pre></div>

<h1 id="section-1">可选安装包</h1>

<h2 id="firewireieee-1394">FireWire总线(IEEE 1394)视频相机支持</h2>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install libdc1394-22-dev</code></pre></div>

<h2 id="section-2">视频流库</h2>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install libxine-dev libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev</code></pre></div>

<h2 id="pythonnumpy">Python开发环境以及NumPy数学工具包</h2>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install python-dev python-numpy</code></pre></div>

<h2 id="intel-tbb">并行程序处理库(Intel TBB库)</h2>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install libtbb-dev</code></pre></div>

<h2 id="qt">Qt开发库</h2>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get -y install libqt4-dev</code></pre></div>

<h1 id="section-3">安装编译</h1>
<p>下载2.4.x版本，目前(2014-7.31)最新版本为2.4.9，针对3.0以后的版本可能会不适用。
解压到工作目录下。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd </span>opencv-2.4.*
mkdir build
<span class="nb">cd </span>build</code></pre></div>

<p>配置CMake参数。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">cmake -D <span class="nv">CMAKE_BUILD_TYPE</span><span class="o">=</span>RELEASE -D <span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">=</span>/usr/local -D <span class="nv">WITH_TBB</span><span class="o">=</span>ON -D <span class="nv">BUILD_NEW_PYTHON_SUPPORT</span><span class="o">=</span>ON -D <span class="nv">WITH_V4L</span><span class="o">=</span>ON -D <span class="nv">INSTALL_C_EXAMPLES</span><span class="o">=</span>ON -D <span class="nv">INSTALL_PYTHON_EXAMPLES</span><span class="o">=</span>ON -D <span class="nv">BUILD_EXAMPLES</span><span class="o">=</span>ON -D <span class="nv">WITH_QT</span><span class="o">=</span>ON -D <span class="nv">WITH_OPENGL</span><span class="o">=</span>ON ..</code></pre></div>

<p>编译(此步耗时最长)</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">make</code></pre></div>

<p>安装完成</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo make install</code></pre></div>

<h1 id="section-4">基本说明</h1>

<p>按照以上步骤安装完成后，可以在<code>/usr/local/lib</code>下找到动态库文件，在<code>/usr/local/include</code>下找到<code>opencv</code>和<code>opencv2</code>，里面是头文件，
在<code>/usr/local/share</code>下找到<code>OpenCV</code>文件夹，里面有预训练的Haar级联器和LBP级联器文件，以及例程文件夹(<code>samples</code>)。如果这些文件夹
都是存在的，那么安装已经成功。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    Previous
  
  <ul class="inline-list">
    <li>
      
        <span class="current-page">1</span>
      
    </li>
    
      <li>
        
          <a href="http://localhost:4000/blog/page2">2</a>
        
      </li>
    
      <li>
        
          <a href="http://localhost:4000/blog/page3">3</a>
        
      </li>
    
  </ul>
  
    <a href="http://localhost:4000/blog/page2" class="btn">Next</a>
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2014 OnceMore. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49487364-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
          

</body>
</html>
